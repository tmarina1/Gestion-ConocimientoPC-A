CHIP ALU2.0 {
    IN  
        a, b, c, d,       
        sel[2];

    OUT 
      out;

    PARTS:
      DMux4Way(in=true, sel=sel[0..1], a=Op1, b=Op2, c=Op3, d=null);

      And(a=Op1, b=a, out=outAndA);
      Not(in=b, out=AndBNot);
      Xor(a=outAndA, b=AndBNot, out=outXor1);
      Xor(a=outXor1, b=c, out=outXor2);
      //DMux(in=outXor2, sel=, a=, b=);

      And(a=Op2, b=b, out=outAndB);
      Not(in=c, out=AndCNot);
      Xor(a=outAndB, b=AndCNot, out=outXorOP1);
      Xor(a=outXorOP1, b=d, out=outXorOP2);

      And(a=outXor2, b=outXorOP2, out=outAndF);

      mux4(a= outXor2, b=outXorOP2, c=outAndF, d=false, sel=sel[0..1], out=out);
}


@a
D=M
@b
D=D+M
@c
D=D+M

@b
D=M
@c
D=D+M
@d
D=D+M

0
1
0
= 0

1
0
0


/*
      DMux4Way(in=true, sel=sel[0..1], a=Op1, b=Op2, c=Op3, d=null);

      And(a=Op1, b=a, out=outAndA);
      Not(in=b, out=AndBNot);
      Xor(a=outAndA, b=AndBNot, out=outXor1);
      Xor(a=outXor1, b=c, out=outXor2);
      //DMux(in=outXor2, sel=, a=, b=);

      And(a=Op2, b=b, out=outAndB);
      Not(in=c, out=AndCNot);
      Xor(a=outAndB, b=AndCNot, out=outXorOP1);
      Xor(a=outXorOP1, b=d, out=outXorOP2);

      And(a=Op3, b=true, out=Op1)
      And(a=Op3, b=true, out=Op2)
      And(a=outXor2, b=outXorOP2, out=outAndF);

      mux4(a= outXor2, b=outXorOP2, c=outAndF, d=false, sel=sel[0..1], out=out);
      */


